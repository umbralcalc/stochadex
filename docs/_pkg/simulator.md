---
title: "simulator"
logo: true
---
<!-- Code generated by gomarkdoc. DO NOT EDIT -->

# simulator

```go
import "github.com/umbralcalc/stochadex/pkg/simulator"
```

Package simulator provides the core simulation engine and infrastructure for stochadex simulations. It includes the main simulation loop, state management, partition coordination, and execution control mechanisms.

Key Features:

- Partition\-based simulation architecture
- Concurrent execution with goroutine coordination
- State history management and time tracking
- Configurable termination and output conditions
- Flexible timestep control
- Thread\-safe state storage and communication

Architecture Overview: The simulator uses a partition\-based architecture where each partition represents a component of the simulation state. Partitions can communicate through upstream/downstream channels, enabling complex multi\-component simulations with dependencies between components.

Core Components:

- PartitionCoordinator: Orchestrates execution across all partitions
- StateIterator: Manages individual partition execution and communication
- StateTimeStorage: Thread\-safe storage for simulation results
- ConfigGenerator: Creates simulation configurations from settings
- TerminationCondition: Controls when simulations stop
- OutputFunction: Handles result collection and storage

Design Philosophy: The simulator emphasizes modularity, concurrency, and flexibility. It provides a robust foundation for building complex simulations while maintaining good performance characteristics and thread safety.

Usage Patterns:

- Multi\-component system simulation
- Agent\-based modeling with interactions
- Monte Carlo simulations with multiple sources of randomness
- Time\-series analysis and forecasting
- Parameter estimation and optimization

Package simulator provides the core simulation engine and infrastructure for stochadex simulations. It includes the main simulation loop, state management, partition coordination, and execution control mechanisms.

Key Features:

- Partition\-based simulation architecture
- Concurrent execution with goroutine coordination
- State history management and time tracking
- Configurable termination and output conditions
- Flexible timestep control
- Thread\-safe state storage and communication

Architecture Overview: The simulator uses a partition\-based architecture where each partition represents a component of the simulation state. Partitions can communicate through upstream/downstream channels, enabling complex multi\-component simulations with dependencies between components.

Core Components:

- PartitionCoordinator: Orchestrates execution across all partitions
- StateIterator: Manages individual partition execution and communication
- StateTimeStorage: Thread\-safe storage for simulation results
- ConfigGenerator: Creates simulation configurations from settings
- TerminationCondition: Controls when simulations stop
- OutputFunction: Handles result collection and storage

Design Philosophy: The simulator emphasizes modularity, concurrency, and flexibility. It provides a robust foundation for building complex simulations while maintaining good performance characteristics and thread safety.

Usage Patterns:

- Multi\-component system simulation
- Agent\-based modeling with interactions
- Monte Carlo simulations with multiple sources of randomness
- Time\-series analysis and forecasting
- Parameter estimation and optimization

Package simulator provides the core simulation engine and infrastructure for stochadex simulations. It includes the main simulation loop, state management, partition coordination, and execution control mechanisms.

Key Features:

- Partition\-based simulation architecture
- Concurrent execution with goroutine coordination
- State history management and time tracking
- Configurable termination and output conditions
- Flexible timestep control
- Thread\-safe state storage and communication

Architecture Overview: The simulator uses a partition\-based architecture where each partition represents a component of the simulation state. Partitions can communicate through upstream/downstream channels, enabling complex multi\-component simulations with dependencies between components.

Core Components:

- PartitionCoordinator: Orchestrates execution across all partitions
- StateIterator: Manages individual partition execution and communication
- StateTimeStorage: Thread\-safe storage for simulation results
- ConfigGenerator: Creates simulation configurations from settings
- TerminationCondition: Controls when simulations stop
- OutputFunction: Handles result collection and storage

Design Philosophy: The simulator emphasizes modularity, concurrency, and flexibility. It provides a robust foundation for building complex simulations while maintaining good performance characteristics and thread safety.

Usage Patterns:

- Multi\-component system simulation
- Agent\-based modeling with interactions
- Monte Carlo simulations with multiple sources of randomness
- Time\-series analysis and forecasting
- Parameter estimation and optimization

Package simulator provides the core simulation engine and infrastructure for stochadex simulations. It includes the main simulation loop, state management, partition coordination, and execution control mechanisms.

Key Features:

- Partition\-based simulation architecture
- Concurrent execution with goroutine coordination
- State history management and time tracking
- Configurable termination and output conditions
- Flexible timestep control
- Thread\-safe state storage and communication

Architecture Overview: The simulator uses a partition\-based architecture where each partition represents a component of the simulation state. Partitions can communicate through upstream/downstream channels, enabling complex multi\-component simulations with dependencies between components.

Core Components:

- PartitionCoordinator: Orchestrates execution across all partitions
- StateIterator: Manages individual partition execution and communication
- StateTimeStorage: Thread\-safe storage for simulation results
- ConfigGenerator: Creates simulation configurations from settings
- TerminationCondition: Controls when simulations stop
- OutputFunction: Handles result collection and storage

Design Philosophy: The simulator emphasizes modularity, concurrency, and flexibility. It provides a robust foundation for building complex simulations while maintaining good performance characteristics and thread safety.

Usage Patterns:

- Multi\-component system simulation
- Agent\-based modeling with interactions
- Monte Carlo simulations with multiple sources of randomness
- Time\-series analysis and forecasting
- Parameter estimation and optimization

## Index

- [Variables](<#variables>)
- [func RunWithHarnesses\(settings \*Settings, implementations \*Implementations\) error](<#RunWithHarnesses>)
- [type ConfigGenerator](<#ConfigGenerator>)
  - [func NewConfigGenerator\(\) \*ConfigGenerator](<#NewConfigGenerator>)
  - [func \(c \*ConfigGenerator\) GenerateConfigs\(\) \(\*Settings, \*Implementations\)](<#ConfigGenerator.GenerateConfigs>)
  - [func \(c \*ConfigGenerator\) GetGlobalSeed\(\) uint64](<#ConfigGenerator.GetGlobalSeed>)
  - [func \(c \*ConfigGenerator\) GetPartition\(name string\) \*PartitionConfig](<#ConfigGenerator.GetPartition>)
  - [func \(c \*ConfigGenerator\) GetSimulation\(\) \*SimulationConfig](<#ConfigGenerator.GetSimulation>)
  - [func \(c \*ConfigGenerator\) ResetPartition\(name string, config \*PartitionConfig\)](<#ConfigGenerator.ResetPartition>)
  - [func \(c \*ConfigGenerator\) SetGlobalSeed\(seed uint64\)](<#ConfigGenerator.SetGlobalSeed>)
  - [func \(c \*ConfigGenerator\) SetPartition\(config \*PartitionConfig\)](<#ConfigGenerator.SetPartition>)
  - [func \(c \*ConfigGenerator\) SetSimulation\(config \*SimulationConfig\)](<#ConfigGenerator.SetSimulation>)
- [type ConstantTimestepFunction](<#ConstantTimestepFunction>)
  - [func \(t \*ConstantTimestepFunction\) NextIncrement\(timestepsHistory \*CumulativeTimestepsHistory\) float64](<#ConstantTimestepFunction.NextIncrement>)
- [type CumulativeTimestepsHistory](<#CumulativeTimestepsHistory>)
- [type DownstreamStateValues](<#DownstreamStateValues>)
- [type EveryNStepsOutputCondition](<#EveryNStepsOutputCondition>)
  - [func \(c \*EveryNStepsOutputCondition\) IsOutputStep\(partitionName string, state \[\]float64, cumulativeTimesteps float64\) bool](<#EveryNStepsOutputCondition.IsOutputStep>)
- [type EveryStepOutputCondition](<#EveryStepOutputCondition>)
  - [func \(c \*EveryStepOutputCondition\) IsOutputStep\(partitionName string, state \[\]float64, cumulativeTimesteps float64\) bool](<#EveryStepOutputCondition.IsOutputStep>)
- [type ExponentialDistributionTimestepFunction](<#ExponentialDistributionTimestepFunction>)
  - [func NewExponentialDistributionTimestepFunction\(mean float64, seed uint64\) \*ExponentialDistributionTimestepFunction](<#NewExponentialDistributionTimestepFunction>)
  - [func \(t \*ExponentialDistributionTimestepFunction\) NextIncrement\(timestepsHistory \*CumulativeTimestepsHistory\) float64](<#ExponentialDistributionTimestepFunction.NextIncrement>)
- [type Implementations](<#Implementations>)
- [type Iteration](<#Iteration>)
- [type IterationSettings](<#IterationSettings>)
- [type IterationTestHarness](<#IterationTestHarness>)
  - [func \(h \*IterationTestHarness\) Configure\(partitionIndex int, settings \*Settings\)](<#IterationTestHarness.Configure>)
  - [func \(h \*IterationTestHarness\) Iterate\(params \*Params, partitionIndex int, stateHistories \[\]\*StateHistory, timestepsHistory \*CumulativeTimestepsHistory\) \[\]float64](<#IterationTestHarness.Iterate>)
- [type IteratorInputMessage](<#IteratorInputMessage>)
- [type JsonLogChannelOutputFunction](<#JsonLogChannelOutputFunction>)
  - [func NewJsonLogChannelOutputFunction\(filePath string\) \*JsonLogChannelOutputFunction](<#NewJsonLogChannelOutputFunction>)
  - [func \(j \*JsonLogChannelOutputFunction\) Close\(\)](<#JsonLogChannelOutputFunction.Close>)
  - [func \(j \*JsonLogChannelOutputFunction\) Output\(partitionName string, state \[\]float64, cumulativeTimesteps float64\)](<#JsonLogChannelOutputFunction.Output>)
- [type JsonLogEntry](<#JsonLogEntry>)
- [type JsonLogOutputFunction](<#JsonLogOutputFunction>)
  - [func NewJsonLogOutputFunction\(filePath string\) \*JsonLogOutputFunction](<#NewJsonLogOutputFunction>)
  - [func \(j \*JsonLogOutputFunction\) Output\(partitionName string, state \[\]float64, cumulativeTimesteps float64\)](<#JsonLogOutputFunction.Output>)
- [type NamedPartitionIndex](<#NamedPartitionIndex>)
- [type NamedUpstreamConfig](<#NamedUpstreamConfig>)
- [type NilOutputCondition](<#NilOutputCondition>)
  - [func \(c \*NilOutputCondition\) IsOutputStep\(partitionName string, state \[\]float64, cumulativeTimesteps float64\) bool](<#NilOutputCondition.IsOutputStep>)
- [type NilOutputFunction](<#NilOutputFunction>)
  - [func \(f \*NilOutputFunction\) Output\(partitionName string, state \[\]float64, cumulativeTimesteps float64\)](<#NilOutputFunction.Output>)
- [type NumberOfStepsTerminationCondition](<#NumberOfStepsTerminationCondition>)
  - [func \(t \*NumberOfStepsTerminationCondition\) Terminate\(stateHistories \[\]\*StateHistory, timestepsHistory \*CumulativeTimestepsHistory\) bool](<#NumberOfStepsTerminationCondition.Terminate>)
- [type OnlyGivenPartitionsOutputCondition](<#OnlyGivenPartitionsOutputCondition>)
  - [func \(o \*OnlyGivenPartitionsOutputCondition\) IsOutputStep\(partitionName string, state \[\]float64, cumulativeTimesteps float64\) bool](<#OnlyGivenPartitionsOutputCondition.IsOutputStep>)
- [type OutputCondition](<#OutputCondition>)
- [type OutputFunction](<#OutputFunction>)
- [type Params](<#Params>)
  - [func NewParams\(params map\[string\]\[\]float64\) Params](<#NewParams>)
  - [func \(p \*Params\) Get\(name string\) \[\]float64](<#Params.Get>)
  - [func \(p \*Params\) GetCopy\(name string\) \[\]float64](<#Params.GetCopy>)
  - [func \(p \*Params\) GetCopyOk\(name string\) \(\[\]float64, bool\)](<#Params.GetCopyOk>)
  - [func \(p \*Params\) GetIndex\(name string, index int\) float64](<#Params.GetIndex>)
  - [func \(p \*Params\) GetOk\(name string\) \(\[\]float64, bool\)](<#Params.GetOk>)
  - [func \(p \*Params\) Set\(name string, values \[\]float64\)](<#Params.Set>)
  - [func \(p \*Params\) SetIndex\(name string, index int, value float64\)](<#Params.SetIndex>)
  - [func \(p \*Params\) SetPartitionName\(name string\)](<#Params.SetPartitionName>)
- [type PartitionConfig](<#PartitionConfig>)
  - [func LoadPartitionConfigFromYaml\(path string\) \*PartitionConfig](<#LoadPartitionConfigFromYaml>)
  - [func \(p \*PartitionConfig\) Init\(\)](<#PartitionConfig.Init>)
- [type PartitionConfigOrdering](<#PartitionConfigOrdering>)
  - [func \(p \*PartitionConfigOrdering\) Append\(config \*PartitionConfig\)](<#PartitionConfigOrdering.Append>)
- [type PartitionCoordinator](<#PartitionCoordinator>)
  - [func NewPartitionCoordinator\(settings \*Settings, implementations \*Implementations\) \*PartitionCoordinator](<#NewPartitionCoordinator>)
  - [func \(c \*PartitionCoordinator\) ReadyToTerminate\(\) bool](<#PartitionCoordinator.ReadyToTerminate>)
  - [func \(c \*PartitionCoordinator\) RequestMoreIterations\(wg \*sync.WaitGroup\)](<#PartitionCoordinator.RequestMoreIterations>)
  - [func \(c \*PartitionCoordinator\) Run\(\)](<#PartitionCoordinator.Run>)
  - [func \(c \*PartitionCoordinator\) Step\(wg \*sync.WaitGroup\)](<#PartitionCoordinator.Step>)
  - [func \(c \*PartitionCoordinator\) UpdateHistory\(wg \*sync.WaitGroup\)](<#PartitionCoordinator.UpdateHistory>)
- [type PartitionState](<#PartitionState>)
  - [func \(\*PartitionState\) Descriptor\(\) \(\[\]byte, \[\]int\)](<#PartitionState.Descriptor>)
  - [func \(x \*PartitionState\) GetCumulativeTimesteps\(\) float64](<#PartitionState.GetCumulativeTimesteps>)
  - [func \(x \*PartitionState\) GetPartitionName\(\) string](<#PartitionState.GetPartitionName>)
  - [func \(x \*PartitionState\) GetState\(\) \[\]float64](<#PartitionState.GetState>)
  - [func \(\*PartitionState\) ProtoMessage\(\)](<#PartitionState.ProtoMessage>)
  - [func \(x \*PartitionState\) ProtoReflect\(\) protoreflect.Message](<#PartitionState.ProtoReflect>)
  - [func \(x \*PartitionState\) Reset\(\)](<#PartitionState.Reset>)
  - [func \(x \*PartitionState\) String\(\) string](<#PartitionState.String>)
- [type Settings](<#Settings>)
  - [func LoadSettingsFromYaml\(path string\) \*Settings](<#LoadSettingsFromYaml>)
  - [func \(s \*Settings\) Init\(\)](<#Settings.Init>)
- [type SimulationConfig](<#SimulationConfig>)
- [type SimulationConfigStrings](<#SimulationConfigStrings>)
  - [func LoadSimulationConfigStringsFromYaml\(path string\) \*SimulationConfigStrings](<#LoadSimulationConfigStringsFromYaml>)
- [type StateHistory](<#StateHistory>)
  - [func \(s \*StateHistory\) CopyStateRow\(index int\) \[\]float64](<#StateHistory.CopyStateRow>)
  - [func \(s \*StateHistory\) GetNextStateRowToUpdate\(\) \[\]float64](<#StateHistory.GetNextStateRowToUpdate>)
- [type StateIterator](<#StateIterator>)
  - [func NewStateIterator\(iteration Iteration, params Params, partitionName string, partitionIndex int, valueChannels StateValueChannels, outputCondition OutputCondition, outputFunction OutputFunction, initState \[\]float64, initTime float64\) \*StateIterator](<#NewStateIterator>)
  - [func \(s \*StateIterator\) Iterate\(stateHistories \[\]\*StateHistory, timestepsHistory \*CumulativeTimestepsHistory\) \[\]float64](<#StateIterator.Iterate>)
  - [func \(s \*StateIterator\) ReceiveAndIteratePending\(inputChannel \<\-chan \*IteratorInputMessage\)](<#StateIterator.ReceiveAndIteratePending>)
  - [func \(s \*StateIterator\) UpdateHistory\(inputChannel \<\-chan \*IteratorInputMessage\)](<#StateIterator.UpdateHistory>)
- [type StateTimeStorage](<#StateTimeStorage>)
  - [func NewStateTimeStorage\(\) \*StateTimeStorage](<#NewStateTimeStorage>)
  - [func \(s \*StateTimeStorage\) ConcurrentAppend\(name string, time float64, values \[\]float64\)](<#StateTimeStorage.ConcurrentAppend>)
  - [func \(s \*StateTimeStorage\) GetIndex\(name string\) int](<#StateTimeStorage.GetIndex>)
  - [func \(s \*StateTimeStorage\) GetNames\(\) \[\]string](<#StateTimeStorage.GetNames>)
  - [func \(s \*StateTimeStorage\) GetTimes\(\) \[\]float64](<#StateTimeStorage.GetTimes>)
  - [func \(s \*StateTimeStorage\) GetValues\(name string\) \[\]\[\]float64](<#StateTimeStorage.GetValues>)
  - [func \(s \*StateTimeStorage\) SetTimes\(times \[\]float64\)](<#StateTimeStorage.SetTimes>)
  - [func \(s \*StateTimeStorage\) SetValues\(name string, values \[\]\[\]float64\)](<#StateTimeStorage.SetValues>)
- [type StateTimeStorageOutputFunction](<#StateTimeStorageOutputFunction>)
  - [func \(f \*StateTimeStorageOutputFunction\) Output\(partitionName string, state \[\]float64, cumulativeTimesteps float64\)](<#StateTimeStorageOutputFunction.Output>)
- [type StateValueChannels](<#StateValueChannels>)
  - [func \(s \*StateValueChannels\) BroadcastDownstream\(stateValues \[\]float64\)](<#StateValueChannels.BroadcastDownstream>)
  - [func \(s \*StateValueChannels\) UpdateUpstreamParams\(params \*Params\)](<#StateValueChannels.UpdateUpstreamParams>)
- [type StdoutOutputFunction](<#StdoutOutputFunction>)
  - [func \(s \*StdoutOutputFunction\) Output\(partitionName string, state \[\]float64, cumulativeTimesteps float64\)](<#StdoutOutputFunction.Output>)
- [type TerminationCondition](<#TerminationCondition>)
- [type TimeElapsedTerminationCondition](<#TimeElapsedTerminationCondition>)
  - [func \(t \*TimeElapsedTerminationCondition\) Terminate\(stateHistories \[\]\*StateHistory, timestepsHistory \*CumulativeTimestepsHistory\) bool](<#TimeElapsedTerminationCondition.Terminate>)
- [type TimestepFunction](<#TimestepFunction>)
- [type UpstreamConfig](<#UpstreamConfig>)
- [type UpstreamStateValues](<#UpstreamStateValues>)
- [type WebsocketOutputFunction](<#WebsocketOutputFunction>)
  - [func NewWebsocketOutputFunction\(connection \*websocket.Conn, mutex \*sync.Mutex\) \*WebsocketOutputFunction](<#NewWebsocketOutputFunction>)
  - [func \(w \*WebsocketOutputFunction\) Output\(partitionName string, state \[\]float64, cumulativeTimesteps float64\)](<#WebsocketOutputFunction.Output>)


## Variables

<a name="File_cmd_messages_partition_state_proto"></a>


```go
var File_cmd_messages_partition_state_proto protoreflect.FileDescriptor
```

<a name="RunWithHarnesses"></a>

## func [RunWithHarnesses](<https://github.com/umbralcalc/stochadex/blob/main/pkg/simulator/harness.go#L127>)

```go
func RunWithHarnesses(settings *Settings, implementations *Implementations) error
```

RunWithHarnesses runs all iterations, each wrapped in a test harness and returns any errors if found. The simulation is also run twice to check for statefulness residues.

<a name="ConfigGenerator"></a>

## type [ConfigGenerator](<https://github.com/umbralcalc/stochadex/blob/main/pkg/simulator/configs.go#L144-L148>)

ConfigGenerator builds Settings and Implementations programmatically and can generate runnable configs on demand.

```go
type ConfigGenerator struct {
    // contains filtered or unexported fields
}
```

<a name="NewConfigGenerator"></a>

### func [NewConfigGenerator](<https://github.com/umbralcalc/stochadex/blob/main/pkg/simulator/configs.go#L269>)

```go
func NewConfigGenerator() *ConfigGenerator
```

NewConfigGenerator creates a new ConfigGenerator with empty ordering.

<a name="ConfigGenerator.GenerateConfigs"></a>

### func \(\*ConfigGenerator\) [GenerateConfigs](<https://github.com/umbralcalc/stochadex/blob/main/pkg/simulator/configs.go#L199>)

```go
func (c *ConfigGenerator) GenerateConfigs() (*Settings, *Implementations)
```

GenerateConfigs constructs Settings and Implementations ready to run. It computes state widths, converts named references, and configures iterations with their partition indices.

<a name="ConfigGenerator.GetGlobalSeed"></a>

### func \(\*ConfigGenerator\) [GetGlobalSeed](<https://github.com/umbralcalc/stochadex/blob/main/pkg/simulator/configs.go#L151>)

```go
func (c *ConfigGenerator) GetGlobalSeed() uint64
```

GetGlobalSeed returns the current global seed.

<a name="ConfigGenerator.GetPartition"></a>

### func \(\*ConfigGenerator\) [GetPartition](<https://github.com/umbralcalc/stochadex/blob/main/pkg/simulator/configs.go#L176>)

```go
func (c *ConfigGenerator) GetPartition(name string) *PartitionConfig
```

GetPartition retrieves a partition config by name.

<a name="ConfigGenerator.GetSimulation"></a>

### func \(\*ConfigGenerator\) [GetSimulation](<https://github.com/umbralcalc/stochadex/blob/main/pkg/simulator/configs.go#L166>)

```go
func (c *ConfigGenerator) GetSimulation() *SimulationConfig
```

GetSimulation returns the current simulation config.

<a name="ConfigGenerator.ResetPartition"></a>

### func \(\*ConfigGenerator\) [ResetPartition](<https://github.com/umbralcalc/stochadex/blob/main/pkg/simulator/configs.go#L187>)

```go
func (c *ConfigGenerator) ResetPartition(name string, config *PartitionConfig)
```

ResetPartition replaces the config for a partition by name.

<a name="ConfigGenerator.SetGlobalSeed"></a>

### func \(\*ConfigGenerator\) [SetGlobalSeed](<https://github.com/umbralcalc/stochadex/blob/main/pkg/simulator/configs.go#L157>)

```go
func (c *ConfigGenerator) SetGlobalSeed(seed uint64)
```

SetGlobalSeed assigns a random seed to each partition derived from the provided global seed.

<a name="ConfigGenerator.SetPartition"></a>

### func \(\*ConfigGenerator\) [SetPartition](<https://github.com/umbralcalc/stochadex/blob/main/pkg/simulator/configs.go#L181>)

```go
func (c *ConfigGenerator) SetPartition(config *PartitionConfig)
```

SetPartition adds a new partition config. Names must be unique.

<a name="ConfigGenerator.SetSimulation"></a>

### func \(\*ConfigGenerator\) [SetSimulation](<https://github.com/umbralcalc/stochadex/blob/main/pkg/simulator/configs.go#L171>)

```go
func (c *ConfigGenerator) SetSimulation(config *SimulationConfig)
```

SetSimulation sets the current simulation config.

<a name="ConstantTimestepFunction"></a>

## type [ConstantTimestepFunction](<https://github.com/umbralcalc/stochadex/blob/main/pkg/simulator/timesteps.go#L54-L56>)

ConstantTimestepFunction uses a fixed stepsize.

```go
type ConstantTimestepFunction struct {
    Stepsize float64
}
```

<a name="ConstantTimestepFunction.NextIncrement"></a>

### func \(\*ConstantTimestepFunction\) [NextIncrement](<https://github.com/umbralcalc/stochadex/blob/main/pkg/simulator/timesteps.go#L58-L60>)

```go
func (t *ConstantTimestepFunction) NextIncrement(timestepsHistory *CumulativeTimestepsHistory) float64
```



<a name="CumulativeTimestepsHistory"></a>

## type [CumulativeTimestepsHistory](<https://github.com/umbralcalc/stochadex/blob/main/pkg/simulator/histories.go#L78-L83>)

CumulativeTimestepsHistory is a rolling window of cumulative timesteps with NextIncrement and CurrentStepNumber.

```go
type CumulativeTimestepsHistory struct {
    NextIncrement     float64
    Values            *mat.VecDense
    CurrentStepNumber int
    StateHistoryDepth int
}
```

<a name="DownstreamStateValues"></a>

## type [DownstreamStateValues](<https://github.com/umbralcalc/stochadex/blob/main/pkg/simulator/iterator.go#L102-L105>)

DownstreamStateValues contains information to broadcast state values to downstream iterators via channel.

```go
type DownstreamStateValues struct {
    Channel chan []float64
    Copies  int
}
```

<a name="EveryNStepsOutputCondition"></a>

## type [EveryNStepsOutputCondition](<https://github.com/umbralcalc/stochadex/blob/main/pkg/simulator/output.go#L249-L252>)

EveryNStepsOutputCondition emits output once every N steps.

```go
type EveryNStepsOutputCondition struct {
    N int
    // contains filtered or unexported fields
}
```

<a name="EveryNStepsOutputCondition.IsOutputStep"></a>

### func \(\*EveryNStepsOutputCondition\) [IsOutputStep](<https://github.com/umbralcalc/stochadex/blob/main/pkg/simulator/output.go#L254-L258>)

```go
func (c *EveryNStepsOutputCondition) IsOutputStep(partitionName string, state []float64, cumulativeTimesteps float64) bool
```



<a name="EveryStepOutputCondition"></a>

## type [EveryStepOutputCondition](<https://github.com/umbralcalc/stochadex/blob/main/pkg/simulator/output.go#L238>)

EveryStepOutputCondition calls the OutputFunction at every step.

```go
type EveryStepOutputCondition struct{}
```

<a name="EveryStepOutputCondition.IsOutputStep"></a>

### func \(\*EveryStepOutputCondition\) [IsOutputStep](<https://github.com/umbralcalc/stochadex/blob/main/pkg/simulator/output.go#L240-L244>)

```go
func (c *EveryStepOutputCondition) IsOutputStep(partitionName string, state []float64, cumulativeTimesteps float64) bool
```



<a name="ExponentialDistributionTimestepFunction"></a>

## type [ExponentialDistributionTimestepFunction](<https://github.com/umbralcalc/stochadex/blob/main/pkg/simulator/timesteps.go#L66-L70>)

ExponentialDistributionTimestepFunction draws dt from an exponential distribution parameterised by Mean and Seed.

```go
type ExponentialDistributionTimestepFunction struct {
    Mean float64
    Seed uint64
    // contains filtered or unexported fields
}
```

<a name="NewExponentialDistributionTimestepFunction"></a>

### func [NewExponentialDistributionTimestepFunction](<https://github.com/umbralcalc/stochadex/blob/main/pkg/simulator/timesteps.go#L80-L83>)

```go
func NewExponentialDistributionTimestepFunction(mean float64, seed uint64) *ExponentialDistributionTimestepFunction
```

NewExponentialDistributionTimestepFunction constructs an exponential\-dt timestep function given mean and seed.

<a name="ExponentialDistributionTimestepFunction.NextIncrement"></a>

### func \(\*ExponentialDistributionTimestepFunction\) [NextIncrement](<https://github.com/umbralcalc/stochadex/blob/main/pkg/simulator/timesteps.go#L72-L74>)

```go
func (t *ExponentialDistributionTimestepFunction) NextIncrement(timestepsHistory *CumulativeTimestepsHistory) float64
```



<a name="Implementations"></a>

## type [Implementations](<https://github.com/umbralcalc/stochadex/blob/main/pkg/simulator/configs.go#L60-L66>)

Implementations provides concrete implementations for a simulation run.

```go
type Implementations struct {
    Iterations           []Iteration
    OutputCondition      OutputCondition
    OutputFunction       OutputFunction
    TerminationCondition TerminationCondition
    TimestepFunction     TimestepFunction
}
```

<a name="Iteration"></a>

## type [Iteration](<https://github.com/umbralcalc/stochadex/blob/main/pkg/simulator/iterator.go#L83-L91>)

Iteration defines the interface for per\-partition state update functions in stochadex simulations.

The Iteration interface is the fundamental building block for defining how simulation state evolves over time. Each partition in a simulation uses an Iteration to compute its next state values based on the current state, parameters, and time information.

Design Philosophy: The Iteration interface emphasizes modularity and composability. By providing a simple, well\-defined interface, it enables the creation of complex simulations through the combination of simple, focused iterations. This design supports both built\-in iteration types and custom user\-defined iterations.

Interface Methods:

- Configure: Initialize the iteration with simulation settings \(called once\)
- Iterate: Compute the next state values \(called each simulation step\)

Configuration Phase: Configure is called once per partition during simulation setup. It receives:

- partitionIndex: The index of this partition in the simulation
- settings: Global simulation settings and configuration

This phase is used for:

- Initializing random number generators
- Setting up internal data structures
- Configuring iteration\-specific parameters
- Validating configuration parameters

Iteration Phase: Iterate is called each simulation step to compute the next state values. It receives:

- params: Current simulation parameters for this partition
- partitionIndex: The index of this partition
- stateHistories: State histories for all partitions \(for cross\-partition access\)
- timestepsHistory: Time and timestep information

It must return:

- \[\]float64: The next state values for this partition

Implementation Requirements:

- Configure must be called before Iterate
- Iterate must return a slice of the correct length \(matching state width\)
- Iterate should not modify the input parameters or state histories
- Iterate should be deterministic given the same inputs \(for reproducible simulations\)

Example Usage:

```
type MyIteration struct {
    // Internal state
}

func (m *MyIteration) Configure(partitionIndex int, settings *Settings) {
    // Initialize iteration
}

func (m *MyIteration) Iterate(params *Params, partitionIndex int,
                              stateHistories []*StateHistory,
                              timestepsHistory *CumulativeTimestepsHistory) []float64 {
    // Compute next state values
    return []float64{newValue1, newValue2, ...}
}
```

Common Iteration Types:

- Stochastic processes: WienerProcessIteration, PoissonProcessIteration
- Deterministic functions: ValuesFunctionIteration, ConstantValuesIteration
- Aggregation functions: VectorMeanIteration, GroupedAggregationIteration
- User\-defined iterations: Custom implementations for specific needs

Performance Considerations:

- Iterate is called frequently during simulation execution
- Implementations should be optimized for performance
- Avoid expensive computations or memory allocations in Iterate
- Consider caching expensive computations in Configure

Thread Safety:

- Iterate may be called concurrently from multiple goroutines
- Implementations should be thread\-safe or stateless
- Shared mutable state should be protected by synchronization primitives

```go
type Iteration interface {
    Configure(partitionIndex int, settings *Settings)
    Iterate(
        params *Params,
        partitionIndex int,
        stateHistories []*StateHistory,
        timestepsHistory *CumulativeTimestepsHistory,
    ) []float64
}
```

<a name="IterationSettings"></a>

## type [IterationSettings](<https://github.com/umbralcalc/stochadex/blob/main/pkg/simulator/configs.go#L22-L30>)

IterationSettings is the YAML\-loadable per\-partition configuration.

Usage hints:

- Name is used to address partitions in other configs and params maps.
- ParamsFromUpstream forwards outputs from upstream partitions into Params.
- StateWidth and StateHistoryDepth control the size and depth of state.

```go
type IterationSettings struct {
    Name               string                    `yaml:"name"`
    Params             Params                    `yaml:"params"`
    ParamsFromUpstream map[string]UpstreamConfig `yaml:"params_from_upstream,omitempty"`
    InitStateValues    []float64                 `yaml:"init_state_values"`
    Seed               uint64                    `yaml:"seed"`
    StateWidth         int                       `yaml:"state_width"`
    StateHistoryDepth  int                       `yaml:"state_history_depth"`
}
```

<a name="IterationTestHarness"></a>

## type [IterationTestHarness](<https://github.com/umbralcalc/stochadex/blob/main/pkg/simulator/harness.go#L13-L18>)

IterationTestHarness wraps an iteration and performs checks on its behaviour while running.

```go
type IterationTestHarness struct {
    Iteration Iteration
    Err       error
    // contains filtered or unexported fields
}
```

<a name="IterationTestHarness.Configure"></a>

### func \(\*IterationTestHarness\) [Configure](<https://github.com/umbralcalc/stochadex/blob/main/pkg/simulator/harness.go#L20-L23>)

```go
func (h *IterationTestHarness) Configure(partitionIndex int, settings *Settings)
```



<a name="IterationTestHarness.Iterate"></a>

### func \(\*IterationTestHarness\) [Iterate](<https://github.com/umbralcalc/stochadex/blob/main/pkg/simulator/harness.go#L34-L39>)

```go
func (h *IterationTestHarness) Iterate(params *Params, partitionIndex int, stateHistories []*StateHistory, timestepsHistory *CumulativeTimestepsHistory) []float64
```



<a name="IteratorInputMessage"></a>

## type [IteratorInputMessage](<https://github.com/umbralcalc/stochadex/blob/main/pkg/simulator/histories.go#L86-L89>)

IteratorInputMessage carries shared histories into iterator jobs.

```go
type IteratorInputMessage struct {
    StateHistories   []*StateHistory
    TimestepsHistory *CumulativeTimestepsHistory
}
```

<a name="JsonLogChannelOutputFunction"></a>

## type [JsonLogChannelOutputFunction](<https://github.com/umbralcalc/stochadex/blob/main/pkg/simulator/output.go#L108-L110>)

JsonLogChannelOutputFunction writes JSON log entries via a background goroutine using a channel for improved throughput.

```go
type JsonLogChannelOutputFunction struct {
    // contains filtered or unexported fields
}
```

<a name="NewJsonLogChannelOutputFunction"></a>

### func [NewJsonLogChannelOutputFunction](<https://github.com/umbralcalc/stochadex/blob/main/pkg/simulator/output.go#L132-L134>)

```go
func NewJsonLogChannelOutputFunction(filePath string) *JsonLogChannelOutputFunction
```

NewJsonLogChannelOutputFunction creates a JsonLogChannelOutputFunction. Call Close \(defer it\) to ensure flushing at the end of a run.

<a name="JsonLogChannelOutputFunction.Close"></a>

### func \(\*JsonLogChannelOutputFunction\) [Close](<https://github.com/umbralcalc/stochadex/blob/main/pkg/simulator/output.go#L126>)

```go
func (j *JsonLogChannelOutputFunction) Close()
```

Close ensures that the log channel flushes at the end of a run.

<a name="JsonLogChannelOutputFunction.Output"></a>

### func \(\*JsonLogChannelOutputFunction\) [Output](<https://github.com/umbralcalc/stochadex/blob/main/pkg/simulator/output.go#L112-L116>)

```go
func (j *JsonLogChannelOutputFunction) Output(partitionName string, state []float64, cumulativeTimesteps float64)
```



<a name="JsonLogEntry"></a>

## type [JsonLogEntry](<https://github.com/umbralcalc/stochadex/blob/main/pkg/simulator/output.go#L56-L60>)

JsonLogEntry is the serialised record format used by JSON log outputs.

```go
type JsonLogEntry struct {
    PartitionName       string    `json:"partition_name"`
    State               []float64 `json:"state"`
    CumulativeTimesteps float64   `json:"time"`
}
```

<a name="JsonLogOutputFunction"></a>

## type [JsonLogOutputFunction](<https://github.com/umbralcalc/stochadex/blob/main/pkg/simulator/output.go#L63-L66>)

JsonLogOutputFunction writes newline\-delimited JSON log entries.

```go
type JsonLogOutputFunction struct {
    // contains filtered or unexported fields
}
```

<a name="NewJsonLogOutputFunction"></a>

### func [NewJsonLogOutputFunction](<https://github.com/umbralcalc/stochadex/blob/main/pkg/simulator/output.go#L94-L96>)

```go
func NewJsonLogOutputFunction(filePath string) *JsonLogOutputFunction
```

NewJsonLogOutputFunction creates a new JsonLogOutputFunction.

<a name="JsonLogOutputFunction.Output"></a>

### func \(\*JsonLogOutputFunction\) [Output](<https://github.com/umbralcalc/stochadex/blob/main/pkg/simulator/output.go#L68-L72>)

```go
func (j *JsonLogOutputFunction) Output(partitionName string, state []float64, cumulativeTimesteps float64)
```



<a name="NamedPartitionIndex"></a>

## type [NamedPartitionIndex](<https://github.com/umbralcalc/stochadex/blob/main/pkg/simulator/iterator.go#L140-L143>)

NamedPartitionIndex pairs the name of a partition with the partition index assigned to it by the PartitionCoordinator.

```go
type NamedPartitionIndex struct {
    Name  string
    Index int
}
```

<a name="NamedUpstreamConfig"></a>

## type [NamedUpstreamConfig](<https://github.com/umbralcalc/stochadex/blob/main/pkg/simulator/configs.go#L69-L72>)

NamedUpstreamConfig is like UpstreamConfig but refers to upstream by name.

```go
type NamedUpstreamConfig struct {
    Upstream string `yaml:"upstream"`
    Indices  []int  `yaml:"indices,omitempty"`
}
```

<a name="NilOutputCondition"></a>

## type [NilOutputCondition](<https://github.com/umbralcalc/stochadex/blob/main/pkg/simulator/output.go#L227>)

NilOutputCondition never outputs.

```go
type NilOutputCondition struct{}
```

<a name="NilOutputCondition.IsOutputStep"></a>

### func \(\*NilOutputCondition\) [IsOutputStep](<https://github.com/umbralcalc/stochadex/blob/main/pkg/simulator/output.go#L229-L233>)

```go
func (c *NilOutputCondition) IsOutputStep(partitionName string, state []float64, cumulativeTimesteps float64) bool
```



<a name="NilOutputFunction"></a>

## type [NilOutputFunction](<https://github.com/umbralcalc/stochadex/blob/main/pkg/simulator/output.go#L21>)

NilOutputFunction outputs nothing from the simulation.

```go
type NilOutputFunction struct{}
```

<a name="NilOutputFunction.Output"></a>

### func \(\*NilOutputFunction\) [Output](<https://github.com/umbralcalc/stochadex/blob/main/pkg/simulator/output.go#L23-L27>)

```go
func (f *NilOutputFunction) Output(partitionName string, state []float64, cumulativeTimesteps float64)
```



<a name="NumberOfStepsTerminationCondition"></a>

## type [NumberOfStepsTerminationCondition](<https://github.com/umbralcalc/stochadex/blob/main/pkg/simulator/termination.go#L12-L14>)

NumberOfStepsTerminationCondition terminates after MaxNumberOfSteps.

```go
type NumberOfStepsTerminationCondition struct {
    MaxNumberOfSteps int
}
```

<a name="NumberOfStepsTerminationCondition.Terminate"></a>

### func \(\*NumberOfStepsTerminationCondition\) [Terminate](<https://github.com/umbralcalc/stochadex/blob/main/pkg/simulator/termination.go#L16-L19>)

```go
func (t *NumberOfStepsTerminationCondition) Terminate(stateHistories []*StateHistory, timestepsHistory *CumulativeTimestepsHistory) bool
```



<a name="OnlyGivenPartitionsOutputCondition"></a>

## type [OnlyGivenPartitionsOutputCondition](<https://github.com/umbralcalc/stochadex/blob/main/pkg/simulator/output.go#L268-L270>)

OnlyGivenPartitionsOutputCondition emits output only for listed partitions.

```go
type OnlyGivenPartitionsOutputCondition struct {
    Partitions map[string]bool
}
```

<a name="OnlyGivenPartitionsOutputCondition.IsOutputStep"></a>

### func \(\*OnlyGivenPartitionsOutputCondition\) [IsOutputStep](<https://github.com/umbralcalc/stochadex/blob/main/pkg/simulator/output.go#L272-L276>)

```go
func (o *OnlyGivenPartitionsOutputCondition) IsOutputStep(partitionName string, state []float64, cumulativeTimesteps float64) bool
```



<a name="OutputCondition"></a>

## type [OutputCondition](<https://github.com/umbralcalc/stochadex/blob/main/pkg/simulator/output.go#L222-L224>)

OutputCondition decides whether an output should be emitted this step.

```go
type OutputCondition interface {
    IsOutputStep(partitionName string, state []float64, cumulativeTimesteps float64) bool
}
```

<a name="OutputFunction"></a>

## type [OutputFunction](<https://github.com/umbralcalc/stochadex/blob/main/pkg/simulator/output.go#L16-L18>)

OutputFunction writes state/time to an output sink when the OutputCondition is met.

```go
type OutputFunction interface {
    Output(partitionName string, state []float64, cumulativeTimesteps float64)
}
```

<a name="Params"></a>

## type [Params](<https://github.com/umbralcalc/stochadex/blob/main/pkg/simulator/params.go#L47-L50>)

Params stores per\-partition parameter values.

Usage hints:

- Use Get/GetIndex helpers to retrieve, Set/SetIndex to update.
- SetPartitionName improves error messages for missing params.

```go
type Params struct {
    Map map[string][]float64 `yaml:",inline"`
    // contains filtered or unexported fields
}
```

<a name="NewParams"></a>

### func [NewParams](<https://github.com/umbralcalc/stochadex/blob/main/pkg/simulator/params.go#L128>)

```go
func NewParams(params map[string][]float64) Params
```

NewParams constructs a Params instance.

<a name="Params.Get"></a>

### func \(\*Params\) [Get](<https://github.com/umbralcalc/stochadex/blob/main/pkg/simulator/params.go#L70>)

```go
func (p *Params) Get(name string) []float64
```

Get returns parameter values or panics with a helpful message.

<a name="Params.GetCopy"></a>

### func \(\*Params\) [GetCopy](<https://github.com/umbralcalc/stochadex/blob/main/pkg/simulator/params.go#L80>)

```go
func (p *Params) GetCopy(name string) []float64
```

GetCopy returns a copy of parameter values or panics with a helpful message.

<a name="Params.GetCopyOk"></a>

### func \(\*Params\) [GetCopyOk](<https://github.com/umbralcalc/stochadex/blob/main/pkg/simulator/params.go#L59>)

```go
func (p *Params) GetCopyOk(name string) ([]float64, bool)
```

GetCopyOk returns a copy of parameter values if present along with a flag.

<a name="Params.GetIndex"></a>

### func \(\*Params\) [GetIndex](<https://github.com/umbralcalc/stochadex/blob/main/pkg/simulator/params.go#L92>)

```go
func (p *Params) GetIndex(name string, index int) float64
```

GetIndex returns a single parameter value or panics.

<a name="Params.GetOk"></a>

### func \(\*Params\) [GetOk](<https://github.com/umbralcalc/stochadex/blob/main/pkg/simulator/params.go#L53>)

```go
func (p *Params) GetOk(name string) ([]float64, bool)
```

GetOk returns parameter values if present along with a boolean flag.

<a name="Params.Set"></a>

### func \(\*Params\) [Set](<https://github.com/umbralcalc/stochadex/blob/main/pkg/simulator/params.go#L102>)

```go
func (p *Params) Set(name string, values []float64)
```

Set creates or updates parameter values by name.

<a name="Params.SetIndex"></a>

### func \(\*Params\) [SetIndex](<https://github.com/umbralcalc/stochadex/blob/main/pkg/simulator/params.go#L107>)

```go
func (p *Params) SetIndex(name string, index int, value float64)
```

SetIndex updates a single parameter value or panics on invalid index.

<a name="Params.SetPartitionName"></a>

### func \(\*Params\) [SetPartitionName](<https://github.com/umbralcalc/stochadex/blob/main/pkg/simulator/params.go#L123>)

```go
func (p *Params) SetPartitionName(name string)
```

SetPartitionName attaches the owning partition name for better errors.

<a name="PartitionConfig"></a>

## type [PartitionConfig](<https://github.com/umbralcalc/stochadex/blob/main/pkg/simulator/configs.go#L80-L89>)

PartitionConfig defines a partition to add to a simulation.

Usage hints:

- Iteration is not YAML\-serialised; set it programmatically.
- ParamsAsPartitions allows passing partition indices via their names.
- ParamsFromUpstream forwards outputs from named upstream partitions.

```go
type PartitionConfig struct {
    Name               string                         `yaml:"name"`
    Iteration          Iteration                      `yaml:"-"`
    Params             Params                         `yaml:"params"`
    ParamsAsPartitions map[string][]string            `yaml:"params_as_partitions,omitempty"`
    ParamsFromUpstream map[string]NamedUpstreamConfig `yaml:"params_from_upstream,omitempty"`
    InitStateValues    []float64                      `yaml:"init_state_values"`
    StateHistoryDepth  int                            `yaml:"state_history_depth"`
    Seed               uint64                         `yaml:"seed"`
}
```

<a name="LoadPartitionConfigFromYaml"></a>

### func [LoadPartitionConfigFromYaml](<https://github.com/umbralcalc/stochadex/blob/main/pkg/simulator/loaders.go#L31>)

```go
func LoadPartitionConfigFromYaml(path string) *PartitionConfig
```

LoadPartitionConfigFromYaml loads PartitionConfig from a YAML file path.

Usage hints:

- Calls Init to populate missing defaults after unmarshalling.

<a name="PartitionConfig.Init"></a>

### func \(\*PartitionConfig\) [Init](<https://github.com/umbralcalc/stochadex/blob/main/pkg/simulator/configs.go#L92>)

```go
func (p *PartitionConfig) Init()
```

Init ensures params maps are initialised; call after unmarshalling YAML.

<a name="PartitionConfigOrdering"></a>

## type [PartitionConfigOrdering](<https://github.com/umbralcalc/stochadex/blob/main/pkg/simulator/configs.go#L125-L129>)

PartitionConfigOrdering maintains the ordering and lookup for partitions. Can be updated dynamically via Append.

```go
type PartitionConfigOrdering struct {
    Names        []string
    IndexByName  map[string]int
    ConfigByName map[string]*PartitionConfig
}
```

<a name="PartitionConfigOrdering.Append"></a>

### func \(\*PartitionConfigOrdering\) [Append](<https://github.com/umbralcalc/stochadex/blob/main/pkg/simulator/configs.go#L132>)

```go
func (p *PartitionConfigOrdering) Append(config *PartitionConfig)
```

Append inserts another partition into the ordering and updates lookups.

<a name="PartitionCoordinator"></a>

## type [PartitionCoordinator](<https://github.com/umbralcalc/stochadex/blob/main/pkg/simulator/coordinator.go#L107-L113>)

PartitionCoordinator orchestrates iteration work across partitions and applies state/time history updates in a coordinated manner.

The PartitionCoordinator is the central component that manages the execution of all partitions in a simulation. It coordinates the timing, communication, and state updates across all partitions, ensuring proper synchronization and maintaining simulation consistency.

Architecture: The coordinator uses a two\-phase execution model:

1. Iteration Phase: All partitions compute their next state values
2. Update Phase: State and time histories are updated with new values

This design ensures that all partitions see consistent state information during each iteration, preventing race conditions and maintaining simulation determinism.

Concurrency Model:

- Each partition runs in its own goroutine for parallel execution
- Channels are used for inter\-partition communication
- WaitGroups ensure proper synchronization between phases
- Shared state is protected by the coordinator's control flow

Execution Flow:

1. Compute next timestep increment using TimestepFunction
2. Request iterations from all partitions \(parallel execution\)
3. Wait for all iterations to complete
4. Update state and time histories \(parallel execution\)
5. Check termination condition
6. Repeat until termination

Fields:

- Iterators: List of StateIterators, one per partition
- Shared: Shared state and time information accessible to all partitions
- TimestepFunction: Function that determines the next timestep increment
- TerminationCondition: Condition that determines when to stop the simulation
- newWorkChannels: Communication channels for coordinating partition work

Example Usage:

```
coordinator := NewPartitionCoordinator(settings, implementations)

// Run simulation until termination
coordinator.Run()

// Or step-by-step control
for !coordinator.ReadyToTerminate() {
    var wg sync.WaitGroup
    coordinator.Step(&wg)
}
```

Performance:

- O\(p\) time complexity where p is the number of partitions
- Parallel execution of partition iterations
- Efficient channel\-based communication
- Memory usage scales with partition count and state size

Thread Safety:

- Safe for concurrent access to coordinator methods
- Internal synchronization ensures consistent state updates
- Partition communication is thread\-safe through channels

```go
type PartitionCoordinator struct {
    Iterators            []*StateIterator
    Shared               *IteratorInputMessage
    TimestepFunction     TimestepFunction
    TerminationCondition TerminationCondition
    // contains filtered or unexported fields
}
```

<a name="NewPartitionCoordinator"></a>

### func [NewPartitionCoordinator](<https://github.com/umbralcalc/stochadex/blob/main/pkg/simulator/coordinator.go#L199-L202>)

```go
func NewPartitionCoordinator(settings *Settings, implementations *Implementations) *PartitionCoordinator
```

NewPartitionCoordinator wires Settings and Implementations into a runnable coordinator with initial state/time histories and channels.

<a name="PartitionCoordinator.ReadyToTerminate"></a>

### func \(\*PartitionCoordinator\) [ReadyToTerminate](<https://github.com/umbralcalc/stochadex/blob/main/pkg/simulator/coordinator.go#L180>)

```go
func (c *PartitionCoordinator) ReadyToTerminate() bool
```

ReadyToTerminate returns whether the TerminationCondition is met.

<a name="PartitionCoordinator.RequestMoreIterations"></a>

### func \(\*PartitionCoordinator\) [RequestMoreIterations](<https://github.com/umbralcalc/stochadex/blob/main/pkg/simulator/coordinator.go#L117>)

```go
func (c *PartitionCoordinator) RequestMoreIterations(wg *sync.WaitGroup)
```

RequestMoreIterations spawns a goroutine per partition to run ReceiveAndIteratePending.

<a name="PartitionCoordinator.Run"></a>

### func \(\*PartitionCoordinator\) [Run](<https://github.com/umbralcalc/stochadex/blob/main/pkg/simulator/coordinator.go#L188>)

```go
func (c *PartitionCoordinator) Run()
```

Run advances by repeatedly calling Step until termination.

<a name="PartitionCoordinator.Step"></a>

### func \(\*PartitionCoordinator\) [Step](<https://github.com/umbralcalc/stochadex/blob/main/pkg/simulator/coordinator.go#L163>)

```go
func (c *PartitionCoordinator) Step(wg *sync.WaitGroup)
```

Step performs one simulation tick: compute dt, request iterations, then apply state/time updates.

<a name="PartitionCoordinator.UpdateHistory"></a>

### func \(\*PartitionCoordinator\) [UpdateHistory](<https://github.com/umbralcalc/stochadex/blob/main/pkg/simulator/coordinator.go#L135>)

```go
func (c *PartitionCoordinator) UpdateHistory(wg *sync.WaitGroup)
```

UpdateHistory spawns a goroutine per partition to run UpdateHistory and shifts time history forward, adding NextIncrement to t\[0\].

<a name="PartitionState"></a>

## type [PartitionState](<https://github.com/umbralcalc/stochadex/blob/main/pkg/simulator/partition_state.pb.go#L23-L31>)



```go
type PartitionState struct {
    CumulativeTimesteps float64   `protobuf:"fixed64,1,opt,name=cumulative_timesteps,json=cumulativeTimesteps,proto3" json:"cumulative_timesteps,omitempty"`
    PartitionName       string    `protobuf:"bytes,2,opt,name=partition_name,json=partitionName,proto3" json:"partition_name,omitempty"`
    State               []float64 `protobuf:"fixed64,3,rep,packed,name=state,proto3" json:"state,omitempty"`
    // contains filtered or unexported fields
}
```

<a name="PartitionState.Descriptor"></a>

### func \(\*PartitionState\) [Descriptor](<https://github.com/umbralcalc/stochadex/blob/main/pkg/simulator/partition_state.pb.go#L61>)

```go
func (*PartitionState) Descriptor() ([]byte, []int)
```

Deprecated: Use PartitionState.ProtoReflect.Descriptor instead.

<a name="PartitionState.GetCumulativeTimesteps"></a>

### func \(\*PartitionState\) [GetCumulativeTimesteps](<https://github.com/umbralcalc/stochadex/blob/main/pkg/simulator/partition_state.pb.go#L65>)

```go
func (x *PartitionState) GetCumulativeTimesteps() float64
```



<a name="PartitionState.GetPartitionName"></a>

### func \(\*PartitionState\) [GetPartitionName](<https://github.com/umbralcalc/stochadex/blob/main/pkg/simulator/partition_state.pb.go#L72>)

```go
func (x *PartitionState) GetPartitionName() string
```



<a name="PartitionState.GetState"></a>

### func \(\*PartitionState\) [GetState](<https://github.com/umbralcalc/stochadex/blob/main/pkg/simulator/partition_state.pb.go#L79>)

```go
func (x *PartitionState) GetState() []float64
```



<a name="PartitionState.ProtoMessage"></a>

### func \(\*PartitionState\) [ProtoMessage](<https://github.com/umbralcalc/stochadex/blob/main/pkg/simulator/partition_state.pb.go#L46>)

```go
func (*PartitionState) ProtoMessage()
```



<a name="PartitionState.ProtoReflect"></a>

### func \(\*PartitionState\) [ProtoReflect](<https://github.com/umbralcalc/stochadex/blob/main/pkg/simulator/partition_state.pb.go#L48>)

```go
func (x *PartitionState) ProtoReflect() protoreflect.Message
```



<a name="PartitionState.Reset"></a>

### func \(\*PartitionState\) [Reset](<https://github.com/umbralcalc/stochadex/blob/main/pkg/simulator/partition_state.pb.go#L33>)

```go
func (x *PartitionState) Reset()
```



<a name="PartitionState.String"></a>

### func \(\*PartitionState\) [String](<https://github.com/umbralcalc/stochadex/blob/main/pkg/simulator/partition_state.pb.go#L42>)

```go
func (x *PartitionState) String() string
```



<a name="Settings"></a>

## type [Settings](<https://github.com/umbralcalc/stochadex/blob/main/pkg/simulator/configs.go#L33-L37>)

Settings is the YAML\-loadable top\-level simulation configuration.

```go
type Settings struct {
    Iterations            []IterationSettings `yaml:"iterations"`
    InitTimeValue         float64             `yaml:"init_time_value"`
    TimestepsHistoryDepth int                 `yaml:"timesteps_history_depth"`
}
```

<a name="LoadSettingsFromYaml"></a>

### func [LoadSettingsFromYaml](<https://github.com/umbralcalc/stochadex/blob/main/pkg/simulator/loaders.go#L13>)

```go
func LoadSettingsFromYaml(path string) *Settings
```

LoadSettingsFromYaml loads Settings from a YAML file path.

Usage hints:

- Calls Init to populate missing defaults after unmarshalling.

<a name="Settings.Init"></a>

### func \(\*Settings\) [Init](<https://github.com/umbralcalc/stochadex/blob/main/pkg/simulator/configs.go#L41>)

```go
func (s *Settings) Init()
```

Init fills in defaults and ensures maps are initialised. Call immediately after unmarshalling from YAML.

<a name="SimulationConfig"></a>

## type [SimulationConfig](<https://github.com/umbralcalc/stochadex/blob/main/pkg/simulator/configs.go#L105-L111>)

SimulationConfig defines additional run\-level configuration.

```go
type SimulationConfig struct {
    OutputCondition      OutputCondition
    OutputFunction       OutputFunction
    TerminationCondition TerminationCondition
    TimestepFunction     TimestepFunction
    InitTimeValue        float64
}
```

<a name="SimulationConfigStrings"></a>

## type [SimulationConfigStrings](<https://github.com/umbralcalc/stochadex/blob/main/pkg/simulator/configs.go#L115-L121>)

SimulationConfigStrings is the YAML\-loadable version of SimulationConfig, referring to implementations by type names for templating.

```go
type SimulationConfigStrings struct {
    OutputCondition      string  `yaml:"output_condition"`
    OutputFunction       string  `yaml:"output_function"`
    TerminationCondition string  `yaml:"termination_condition"`
    TimestepFunction     string  `yaml:"timestep_function"`
    InitTimeValue        float64 `yaml:"init_time_value"`
}
```

<a name="LoadSimulationConfigStringsFromYaml"></a>

### func [LoadSimulationConfigStringsFromYaml](<https://github.com/umbralcalc/stochadex/blob/main/pkg/simulator/loaders.go#L46>)

```go
func LoadSimulationConfigStringsFromYaml(path string) *SimulationConfigStrings
```

LoadSimulationConfigStringsFromYaml loads SimulationConfigStrings from YAML.

<a name="StateHistory"></a>

## type [StateHistory](<https://github.com/umbralcalc/stochadex/blob/main/pkg/simulator/histories.go#L49-L57>)

StateHistory is a rolling window of state vectors.

Usage hints:

- Values holds rows of state \(row 0 is most recent by convention\).
- Use GetNextStateRowToUpdate when updating in multi\-row histories.

```go
type StateHistory struct {
    // each row is a different state in the history, by convention,
    // starting with the most recent at index = 0
    Values *mat.Dense
    // should be of length = StateWidth
    NextValues        []float64
    StateWidth        int
    StateHistoryDepth int
}
```

<a name="StateHistory.CopyStateRow"></a>

### func \(\*StateHistory\) [CopyStateRow](<https://github.com/umbralcalc/stochadex/blob/main/pkg/simulator/histories.go#L60>)

```go
func (s *StateHistory) CopyStateRow(index int) []float64
```

CopyStateRow copies a row from the state history given the index.

<a name="StateHistory.GetNextStateRowToUpdate"></a>

### func \(\*StateHistory\) [GetNextStateRowToUpdate](<https://github.com/umbralcalc/stochadex/blob/main/pkg/simulator/histories.go#L69>)

```go
func (s *StateHistory) GetNextStateRowToUpdate() []float64
```

GetNextStateRowToUpdate determines whether or not it is necessary to copy the previous row or simply expose it based on whether a history longer than 1 is needed.

<a name="StateIterator"></a>

## type [StateIterator](<https://github.com/umbralcalc/stochadex/blob/main/pkg/simulator/iterator.go#L147-L154>)

StateIterator runs an Iteration for a partition on a goroutine and manages reads/writes to history and output.

```go
type StateIterator struct {
    Iteration       Iteration
    Params          Params
    Partition       NamedPartitionIndex
    ValueChannels   StateValueChannels
    OutputCondition OutputCondition
    OutputFunction  OutputFunction
}
```

<a name="NewStateIterator"></a>

### func [NewStateIterator](<https://github.com/umbralcalc/stochadex/blob/main/pkg/simulator/iterator.go#L211-L221>)

```go
func NewStateIterator(iteration Iteration, params Params, partitionName string, partitionIndex int, valueChannels StateValueChannels, outputCondition OutputCondition, outputFunction OutputFunction, initState []float64, initTime float64) *StateIterator
```

NewStateIterator creates a StateIterator and may emit initial output if the condition is met by the initial state/time.

<a name="StateIterator.Iterate"></a>

### func \(\*StateIterator\) [Iterate](<https://github.com/umbralcalc/stochadex/blob/main/pkg/simulator/iterator.go#L158-L161>)

```go
func (s *StateIterator) Iterate(stateHistories []*StateHistory, timestepsHistory *CumulativeTimestepsHistory) []float64
```

Iterate runs the Iteration and optionally triggers output if the condition is met for the new state/time.

<a name="StateIterator.ReceiveAndIteratePending"></a>

### func \(\*StateIterator\) [ReceiveAndIteratePending](<https://github.com/umbralcalc/stochadex/blob/main/pkg/simulator/iterator.go#L179-L181>)

```go
func (s *StateIterator) ReceiveAndIteratePending(inputChannel <-chan *IteratorInputMessage)
```

ReceiveAndIteratePending listens for an IteratorInputMessage, updates upstream\-driven params, runs Iterate, and stores a pending state update.

<a name="StateIterator.UpdateHistory"></a>

### func \(\*StateIterator\) [UpdateHistory](<https://github.com/umbralcalc/stochadex/blob/main/pkg/simulator/iterator.go#L196>)

```go
func (s *StateIterator) UpdateHistory(inputChannel <-chan *IteratorInputMessage)
```

UpdateHistory applies the pending state update to the partition history.

<a name="StateTimeStorage"></a>

## type [StateTimeStorage](<https://github.com/umbralcalc/stochadex/blob/main/pkg/simulator/storage.go#L65-L70>)

StateTimeStorage provides thread\-safe storage for simulation time series data with minimal contention and efficient access patterns.

StateTimeStorage is designed to handle concurrent access from multiple simulation partitions while maintaining data consistency and performance. It uses a mutex\-protected design optimized for the common case of appending new data points during simulation execution.

Data Organization:

- Time series are organized by partition name
- Each partition can have multiple state dimensions
- Time axis is shared across all partitions
- Data is stored in row\-major format for efficient access

Thread Safety:

- ConcurrentAppend is safe for concurrent use from multiple goroutines
- GetValues/GetTimes are safe for concurrent reads
- SetValues/SetTimes should not be called concurrently with appends
- Internal mutex protects against race conditions

Performance Characteristics:

- O\(1\) lookup by partition name using hash map
- O\(1\) append operations with minimal locking
- Memory usage: O\(total\_samples \* state\_dimensions\)
- Efficient for high\-frequency data collection

Usage Patterns:

- Real\-time data collection during simulation runs
- Batch data loading from external sources
- Result storage for post\-simulation analysis
- Intermediate storage for multi\-stage simulations

Example Usage:

```
storage := NewStateTimeStorage()

// Concurrent appends from multiple partitions
go func() {
    storage.ConcurrentAppend("prices", 1.0, []float64{100.0, 101.0})
}()
go func() {
    storage.ConcurrentAppend("volumes", 1.0, []float64{1000.0})
}()

// Retrieve data after simulation
priceData := storage.GetValues("prices")
timeData := storage.GetTimes()
```

Memory Management:

- Automatic memory allocation for new partitions
- Efficient storage of sparse time series
- No automatic cleanup \(caller responsible for memory management\)

Error Handling:

- GetValues panics if partition name is not found
- Provides helpful error messages with available partition names
- ConcurrentAppend handles time deduplication automatically

```go
type StateTimeStorage struct {
    // contains filtered or unexported fields
}
```

<a name="NewStateTimeStorage"></a>

### func [NewStateTimeStorage](<https://github.com/umbralcalc/stochadex/blob/main/pkg/simulator/storage.go#L152>)

```go
func NewStateTimeStorage() *StateTimeStorage
```

NewStateTimeStorage constructs a new StateTimeStorage.

<a name="StateTimeStorage.ConcurrentAppend"></a>

### func \(\*StateTimeStorage\) [ConcurrentAppend](<https://github.com/umbralcalc/stochadex/blob/main/pkg/simulator/storage.go#L121-L125>)

```go
func (s *StateTimeStorage) ConcurrentAppend(name string, time float64, values []float64)
```

ConcurrentAppend appends values for name and updates the time axis at most once per unique timestamp. Safe for concurrent use.

<a name="StateTimeStorage.GetIndex"></a>

### func \(\*StateTimeStorage\) [GetIndex](<https://github.com/umbralcalc/stochadex/blob/main/pkg/simulator/storage.go#L73>)

```go
func (s *StateTimeStorage) GetIndex(name string) int
```

GetIndex returns or creates the index for a name.

<a name="StateTimeStorage.GetNames"></a>

### func \(\*StateTimeStorage\) [GetNames](<https://github.com/umbralcalc/stochadex/blob/main/pkg/simulator/storage.go#L85>)

```go
func (s *StateTimeStorage) GetNames() []string
```

GetNames returns all partition names present in the store.

<a name="StateTimeStorage.GetTimes"></a>

### func \(\*StateTimeStorage\) [GetTimes](<https://github.com/umbralcalc/stochadex/blob/main/pkg/simulator/storage.go#L110>)

```go
func (s *StateTimeStorage) GetTimes() []float64
```

GetTimes returns the time axis.

<a name="StateTimeStorage.GetValues"></a>

### func \(\*StateTimeStorage\) [GetValues](<https://github.com/umbralcalc/stochadex/blob/main/pkg/simulator/storage.go#L94>)

```go
func (s *StateTimeStorage) GetValues(name string) [][]float64
```

GetValues returns all time series for name, panicking if absent.

<a name="StateTimeStorage.SetTimes"></a>

### func \(\*StateTimeStorage\) [SetTimes](<https://github.com/umbralcalc/stochadex/blob/main/pkg/simulator/storage.go#L115>)

```go
func (s *StateTimeStorage) SetTimes(times []float64)
```

SetTimes replaces the time axis.

<a name="StateTimeStorage.SetValues"></a>

### func \(\*StateTimeStorage\) [SetValues](<https://github.com/umbralcalc/stochadex/blob/main/pkg/simulator/storage.go#L105>)

```go
func (s *StateTimeStorage) SetValues(name string, values [][]float64)
```

SetValues replaces the entire series for name.

<a name="StateTimeStorageOutputFunction"></a>

## type [StateTimeStorageOutputFunction](<https://github.com/umbralcalc/stochadex/blob/main/pkg/simulator/output.go#L43-L45>)

StateTimeStorageOutputFunction stores output into StateTimeStorage when the condition is met.

```go
type StateTimeStorageOutputFunction struct {
    Store *StateTimeStorage
}
```

<a name="StateTimeStorageOutputFunction.Output"></a>

### func \(\*StateTimeStorageOutputFunction\) [Output](<https://github.com/umbralcalc/stochadex/blob/main/pkg/simulator/output.go#L47-L51>)

```go
func (f *StateTimeStorageOutputFunction) Output(partitionName string, state []float64, cumulativeTimesteps float64)
```



<a name="StateValueChannels"></a>

## type [StateValueChannels](<https://github.com/umbralcalc/stochadex/blob/main/pkg/simulator/iterator.go#L109-L112>)

StateValueChannels provides upstream/downstream channels for inter\-iterator communication.

```go
type StateValueChannels struct {
    Upstreams  map[string]*UpstreamStateValues
    Downstream *DownstreamStateValues
}
```

<a name="StateValueChannels.BroadcastDownstream"></a>

### func \(\*StateValueChannels\) [BroadcastDownstream](<https://github.com/umbralcalc/stochadex/blob/main/pkg/simulator/iterator.go#L132>)

```go
func (s *StateValueChannels) BroadcastDownstream(stateValues []float64)
```

BroadcastDownstream sends state values to all configured downstream copies.

<a name="StateValueChannels.UpdateUpstreamParams"></a>

### func \(\*StateValueChannels\) [UpdateUpstreamParams](<https://github.com/umbralcalc/stochadex/blob/main/pkg/simulator/iterator.go#L116>)

```go
func (s *StateValueChannels) UpdateUpstreamParams(params *Params)
```

UpdateUpstreamParams updates Params with values received from upstream channels.

<a name="StdoutOutputFunction"></a>

## type [StdoutOutputFunction](<https://github.com/umbralcalc/stochadex/blob/main/pkg/simulator/output.go#L31>)

StdoutOutputFunction outputs the state to the terminal.

```go
type StdoutOutputFunction struct{}
```

<a name="StdoutOutputFunction.Output"></a>

### func \(\*StdoutOutputFunction\) [Output](<https://github.com/umbralcalc/stochadex/blob/main/pkg/simulator/output.go#L33-L37>)

```go
func (s *StdoutOutputFunction) Output(partitionName string, state []float64, cumulativeTimesteps float64)
```



<a name="TerminationCondition"></a>

## type [TerminationCondition](<https://github.com/umbralcalc/stochadex/blob/main/pkg/simulator/termination.go#L4-L9>)

TerminationCondition decides when the simulation should end.

```go
type TerminationCondition interface {
    Terminate(
        stateHistories []*StateHistory,
        timestepsHistory *CumulativeTimestepsHistory,
    ) bool
}
```

<a name="TimeElapsedTerminationCondition"></a>

## type [TimeElapsedTerminationCondition](<https://github.com/umbralcalc/stochadex/blob/main/pkg/simulator/termination.go#L24-L26>)

TimeElapsedTerminationCondition terminates after MaxTimeElapsed.

```go
type TimeElapsedTerminationCondition struct {
    MaxTimeElapsed float64
}
```

<a name="TimeElapsedTerminationCondition.Terminate"></a>

### func \(\*TimeElapsedTerminationCondition\) [Terminate](<https://github.com/umbralcalc/stochadex/blob/main/pkg/simulator/termination.go#L28-L31>)

```go
func (t *TimeElapsedTerminationCondition) Terminate(stateHistories []*StateHistory, timestepsHistory *CumulativeTimestepsHistory) bool
```



<a name="TimestepFunction"></a>

## type [TimestepFunction](<https://github.com/umbralcalc/stochadex/blob/main/pkg/simulator/timesteps.go#L47-L51>)

TimestepFunction computes the next time increment.

```go
type TimestepFunction interface {
    NextIncrement(
        timestepsHistory *CumulativeTimestepsHistory,
    ) float64
}
```

<a name="UpstreamConfig"></a>

## type [UpstreamConfig](<https://github.com/umbralcalc/stochadex/blob/main/pkg/simulator/configs.go#L11-L14>)

UpstreamConfig is the YAML\-loadable representation of a slice of data from the output of a partition which is computationally upstream.

```go
type UpstreamConfig struct {
    Upstream int   `yaml:"upstream"`
    Indices  []int `yaml:"indices,omitempty"`
}
```

<a name="UpstreamStateValues"></a>

## type [UpstreamStateValues](<https://github.com/umbralcalc/stochadex/blob/main/pkg/simulator/iterator.go#L95-L98>)

UpstreamStateValues contains information to receive state values from an upstream iterator via channel.

```go
type UpstreamStateValues struct {
    Channel chan []float64
    Indices []int
}
```

<a name="WebsocketOutputFunction"></a>

## type [WebsocketOutputFunction](<https://github.com/umbralcalc/stochadex/blob/main/pkg/simulator/output.go#L170-L173>)

WebsocketOutputFunction serialises and sends outputs via a websocket connection when the condition is met.

```go
type WebsocketOutputFunction struct {
    // contains filtered or unexported fields
}
```

<a name="NewWebsocketOutputFunction"></a>

### func [NewWebsocketOutputFunction](<https://github.com/umbralcalc/stochadex/blob/main/pkg/simulator/output.go#L214-L217>)

```go
func NewWebsocketOutputFunction(connection *websocket.Conn, mutex *sync.Mutex) *WebsocketOutputFunction
```

NewWebsocketOutputFunction constructs a WebsocketOutputFunction with a connection and a mutex for safe concurrent writes.

<a name="WebsocketOutputFunction.Output"></a>

### func \(\*WebsocketOutputFunction\) [Output](<https://github.com/umbralcalc/stochadex/blob/main/pkg/simulator/output.go#L175-L179>)

```go
func (w *WebsocketOutputFunction) Output(partitionName string, state []float64, cumulativeTimesteps float64)
```



Generated by [gomarkdoc](<https://github.com/princjef/gomarkdoc>)
